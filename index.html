<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>METROID-VANIA: GOLIATH FORCE</title>
    <style>
        body { 
            background: #000; color: #eee; font-family: 'serif', 'Palatino', 'Georgia'; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            height: 100vh; margin: 0; overflow: hidden; 
        }
        #game-container { position: relative; border: 2px solid #222; box-shadow: 0 0 100px #400; }
        #player-ui { position: absolute; top: 20px; left: 20px; display: flex; gap: 10px; z-index: 10; }
        .heart { 
            width: 30px; height: 30px; background: #f00; 
            clip-path: polygon(50% 15%, 80% 0%, 100% 20%, 100% 50%, 50% 100%, 0% 50%, 0% 20%, 20% 0%);
            transition: transform 0.3s;
        }
        .heart.lost { background: #333; transform: scale(0.8); }
        #boss-ui {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 80%; text-align: center;
        }
        #boss-name { text-transform: uppercase; letter-spacing: 5px; font-size: 1.4em; margin-bottom: 8px; color: #fff; text-shadow: 0 0 10px #f00; }
        .boss-bar-bg { width: 100%; height: 16px; background: rgba(50, 0, 0, 0.7); border: 1px solid #600; position: relative; }
        .boss-bar-white { position: absolute; height: 100%; background: #fff; width: 100%; transition: width 0.6s ease-out; }
        .boss-bar-fill { position: absolute; height: 100%; background: linear-gradient(to right, #600, #f00); width: 100%; transition: width 0.2s; }
        canvas { background: #0a0a0f; image-rendering: pixelated; width: 1000px; height: 625px; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.9); z-index: 500; text-align: center;
        }
        #start-screen h1 { font-size: 4em; color: #fff; text-shadow: 0 0 20px #f00; margin-bottom: 10px; }
        #death-screen { display: none; background: rgba(60, 0, 0, 0.9); }
        #death-screen h2 { font-size: 5em; color: #f00; text-shadow: 0 0 30px #000; }

        .level-select { display: flex; gap: 15px; margin-top: 20px; }
        .lvl-btn {
            background: transparent; border: 1px solid #555; color: #aaa;
            padding: 10px 20px; cursor: pointer; transition: all 0.2s;
            text-transform: uppercase; font-family: inherit;
        }
        .lvl-btn:hover { border-color: #f00; color: #fff; background: rgba(255,0,0,0.1); }

        #stage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.7); pointer-events: none; opacity: 0; transition: opacity 0.5s;
            font-size: 3em; color: white; text-shadow: 0 0 20px #f00; z-index: 100;
        }

        #pause-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; border: 2px solid #444;
        }
        .menu-btn {
            background: #222; color: #fff; border: 1px solid #444;
            padding: 15px 40px; margin: 10px; font-size: 1.2em; cursor: pointer;
            width: 250px; transition: all 0.2s; font-family: inherit;
        }
        .menu-btn:hover { background: #444; border-color: #0af; transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="start-screen" class="overlay-screen">
            <h1>GOLIATH FORCE</h1>
            <p style="font-size: 1.2em; color: #888;">PRESS [ENTER] FOR NEW GAME OR SELECT STAGE</p>
            
            <div class="level-select">
                <button class="lvl-btn" onclick="startAtLevel(0)">Level 1</button>
                <button class="lvl-btn" onclick="startAtLevel(1)">Level 2</button>
                <button class="lvl-btn" onclick="startAtLevel(2)">Level 3</button>
            </div>

            <p style="color: #555; margin-top: 40px; font-size: 0.9em;">[A/D] Move | [SPACE] Jump | [K] Shoot | [W/S] Aim | [SHIFT] Dash</p>
        </div>

        <div id="death-screen" class="overlay-screen">
            <h2>YOU PERISHED</h2>
            <button class="menu-btn" onclick="location.reload()">MAIN MENU</button>
        </div>

        <div id="stage-overlay">STAGE START</div>
        
        <div id="pause-menu">
            <h2>GAME PAUSED</h2>
            <button class="menu-btn" onclick="togglePause()">RESUME</button>
            <button class="menu-btn" onclick="location.reload()">QUIT TO MENU</button>
        </div>

        <div id="player-ui">
            <div id="h1" class="heart"></div>
            <div id="h2" class="heart"></div>
            <div id="h3" class="heart"></div>
        </div>

        <div id="boss-ui">
            <div id="boss-name">THE VOID SORCERER</div>
            <div class="boss-bar-bg">
                <div id="bossWhite" class="boss-bar-white"></div>
                <div id="bossFill" class="boss-bar-fill"></div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const images = {
    player: new Image(), boss: new Image(), bullet: new Image(),
    background: new Image(), platform: new Image(), floor: new Image(), fireball: new Image(),
    slash: new Image() // New slash image container
};

images.player.src = 'player.png';
images.fireball.src = 'fireball.png';
images.slash.src = 'slash.png'; // Looks for slash.png

function isImgLoaded(img) { return img.complete && img.naturalWidth !== 0; }

const GRAVITY = 0.35;
const JUMP = -8.5;
const FLOOR_Y = 460;
const PLAYER_SPD = 4.2;
const DASH_SPD = 14.0; 
const PLAT_HEIGHT = 35;
const MARGIN = 40; 

let currentStage = 0;
let bossProjectiles = [], playerProjectiles = [], afterImages = [], muzzleFlashes = [], sparks = []; 
let keys = {}, shake = 0, isPaused = false, gameStarted = false, isDead = false, hitStop = 0;

let player = { 
    x: 100, y: 300, w: 40, h: 60, hw: 28, hh: 52, vx: 0, vy: 0, 
    jumps: 0, dir: 1, hp: 3, inv: 0, shootTimer: 0, dashTimer: 0, 
    dashCooldown: 0, recoilX: 0 
};
let boss = { x: 500, y: 100, w: 120, h: 140, hp: 0, max: 0, flicker: 0, stateTimer: 0 };

const STAGES = [
    { n: "THE VOID SORCERER", bgClr: "#0d0a1a", bc: "#80f", hp: 50, plats: [[100,320,150], [550,320,150]], move: 'sine', attack: 'shotgun', srcs: { boss: 'boss.png', bg: 'background.png', platform: 'platform.png', floor: 'floor.png', bullet: 'bullet.png' }, sizeMult: 1.0, hitBoxMult: 0.8 },
    { n: "BONE HYDRA", bgClr: "#1a1a1a", bc: "#ddd", hp: 80, plats: [[40,340,240], [520,340,240], [250,210,300]], move: 'swoop', attack: 'circle', srcs: { boss: 'boss2.png', bg: 'background2.png', platform: 'platform2.png', floor: 'floor2.png', bullet: 'bone.png' }, sizeMult: 1.4, hitBoxMult: 0.6 },
    { n: "BLOOD SERAPH", bgClr: "#200", bc: "#f33", hp: 120, plats: [[0,310,220], [580,310,220], [270,160,260]], move: 'teleport', attack: 'slash_dynamic', srcs: { boss: 'boss3.png', bg: 'background3.png', platform: 'platform3.png', floor: 'floor3.png', bullet: 'blood.png' }, sizeMult: 1.2, hitBoxMult: 0.8 }
];

function startAtLevel(idx) {
    currentStage = idx;
    gameStarted = true;
    document.getElementById('start-screen').style.display = 'none';
    initStage();
    draw();
}

window.onkeydown = (e) => {
    if (e.code === 'Enter' && !gameStarted) startAtLevel(0);
    if (!gameStarted || isDead) return;
    if (e.code === 'Escape') togglePause();
    if (isPaused) return;
    if (e.code === 'Space' && player.jumps < 2) { player.vy = JUMP; player.jumps++; }
    if (e.code === 'KeyK') shootFireball();
    if (e.shiftKey && player.dashCooldown <= 0) { player.dashTimer = 10; player.dashCooldown = 40; }
    keys[e.code] = true;
};
window.onkeyup = (e) => keys[e.code] = false;

function togglePause() {
    isPaused = !isPaused;
    document.getElementById('pause-menu').style.display = isPaused ? 'flex' : 'none';
}

function createSparks(x, y, color) {
    for (let i = 0; i < 8; i++) {
        sparks.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color,
            size: 2 + Math.random() * 3
        });
    }
}

function shootFireball() {
    if (player.shootTimer <= 0) {
        let vx = 0, vy = 0, speed = 14; 
        if (keys['KeyW']) vy = -speed;
        else if (keys['KeyS']) vy = speed;
        if (keys['KeyA']) { vx = -speed; player.dir = -1; }
        else if (keys['KeyD']) { vx = speed; player.dir = 1; }
        else if (vy === 0) vx = player.dir * speed;
        if (vx !== 0 && vy !== 0) { vx *= 0.707; vy *= 0.707; }
        
        playerProjectiles.push({ x: player.x + player.w/2, y: player.y + player.h/2, vx, vy, size: 24 });
        player.recoilX = -player.dir * 6;
        muzzleFlashes.push({ x: player.x + player.w/2 + (player.dir * 25), y: player.y + player.h/2, life: 4 });
        shake = 3; 
        player.shootTimer = 12; 
    }
}

function initStage() {
    const s = STAGES[currentStage % STAGES.length];
    images.boss.src = s.srcs.boss; images.background.src = s.srcs.bg; images.platform.src = s.srcs.platform;
    images.floor.src = s.srcs.floor; images.bullet.src = s.srcs.bullet;
    player.x = 100; player.y = FLOOR_Y - player.h; player.hp = 3; player.inv = 0;
    boss.h = 140 * s.sizeMult; boss.w = 120 * s.sizeMult;
    boss.hp = s.hp; boss.max = s.hp; boss.x = 600; boss.y = 100; boss.stateTimer = 0;
    bossProjectiles = []; playerProjectiles = []; afterImages = []; muzzleFlashes = []; sparks = [];
    document.getElementById('boss-name').innerText = s.n;
    const overlay = document.getElementById('stage-overlay');
    overlay.innerText = s.n; overlay.style.opacity = 1;
    setTimeout(() => { overlay.style.opacity = 0; }, 2000);
    updateUI();
}

function updateUI() {
    for(let i=1; i<=3; i++) {
        const h = document.getElementById(`h${i}`);
        if(i > player.hp) h.classList.add('lost'); else h.classList.remove('lost');
    }
    const pct = (boss.hp / boss.max) * 100;
    document.getElementById('bossFill').style.width = pct + "%";
    setTimeout(() => { document.getElementById('bossWhite').style.width = pct + "%"; }, 250);
}

function update() {
    if (isPaused || !gameStarted || isDead) return;
    if (hitStop > 0) { hitStop--; return; }

    let s = STAGES[currentStage % STAGES.length];
    let hpPct = (boss.hp / boss.max);

    // Player Physics
    if (player.dashTimer > 0) {
        player.vx = player.dir * DASH_SPD; player.vy = 0; player.dashTimer--;
        if (player.dashTimer % 2 === 0) afterImages.push({ x: player.x, y: player.y, opacity: 0.6, color: "#0af", isPlayer: true, dir: player.dir, w: player.w, h: player.h });
    } else {
        if (keys['KeyA']) { player.vx = -PLAYER_SPD; player.dir = -1; }
        else if (keys['KeyD']) { player.vx = PLAYER_SPD; player.dir = 1; }
        else player.vx *= 0.85;
        player.vy += GRAVITY;
    }
    
    player.x += player.vx; 
    player.y += player.vy;
    player.recoilX *= 0.8; 

    if (player.shootTimer > 0) player.shootTimer--;
    if (player.dashCooldown > 0) player.dashCooldown--;

    if (player.y + player.h > FLOOR_Y) { player.y = FLOOR_Y - player.h; player.vy = 0; player.jumps = 0; }
    s.plats.forEach(p => {
        if (player.vy > 0 && player.x + player.w*0.8 > p[0] && player.x + player.w*0.2 < p[0] + p[2] && 
            player.y + player.h >= p[1] && player.y + player.h <= p[1] + 15) {
            player.y = p[1] - player.h; player.vy = 0; player.jumps = 0;
        }
    });
    player.x = Math.max(0, Math.min(player.x, canvas.width - player.w));

    // Boss AI
    boss.stateTimer++;
    if (boss.stateTimer % 15 === 0) afterImages.push({ x: boss.x, y: boss.y, opacity: 0.3, color: s.bc, isPlayer: false, w: boss.w, h: boss.h });

    switch(s.move) {
        case 'sine': 
            boss.x += Math.cos(Date.now() / 800) * 5; 
            boss.y = 80 + Math.sin(Date.now() / 400) * 70; 
            break;
        case 'swoop': 
            let targetSide = (player.x > canvas.width / 2) ? -220 : 220;
            let tx = player.x + targetSide;
            let ty = player.y - 120 + Math.sin(boss.stateTimer * 0.05) * 60;
            boss.x += (tx - boss.x) * 0.035;
            boss.y += (ty - boss.y) * 0.035;
            break;
        case 'teleport': 
            let telFreq = (hpPct <= 0.5) ? 70 : 110;
            if (boss.stateTimer % telFreq === 0) { 
                boss.x = MARGIN + Math.random() * (canvas.width - boss.w - MARGIN*2); 
                boss.y = MARGIN + Math.random() * (FLOOR_Y - boss.h - MARGIN*2); 
                shake = 10; 
            } 
            break;
    }

    boss.x = Math.max(MARGIN, Math.min(boss.x, canvas.width - boss.w - MARGIN));
    boss.y = Math.max(MARGIN, Math.min(boss.y, FLOOR_Y - boss.h - MARGIN));

    // Attack Patterns
    if (boss.stateTimer % 85 === 0) {
        const bx = boss.x + boss.w/2, by = boss.y + boss.h/2;
        if(s.attack === 'shotgun') {
            for(let i=-1; i<=1; i++) bossProjectiles.push({ x: bx, y: by, vx: Math.cos(Math.atan2(player.y - by, player.x - bx) + i*0.3)*6, vy: Math.sin(Math.atan2(player.y - by, player.x - bx) + i*0.3)*6, size: 18 });
        } else if(s.attack === 'circle') {
            for(let i=0; i<8; i++) bossProjectiles.push({ x: bx, y: by, vx: Math.cos((Math.PI*2/8)*i)*4, vy: Math.sin((Math.PI*2/8)*i)*4, size: 15 });
        } else if(s.attack === 'slash_dynamic') {
            const ang = Math.atan2(player.y - by, player.x - bx);
            let count = (hpPct <= 0.5) ? 3 : 1;
            for(let i=0; i<count; i++) {
                let finalAng = ang + (i - (count-1)/2) * 0.25;
                bossProjectiles.push({ x: bx, y: by, vx: Math.cos(finalAng)*8, vy: Math.sin(finalAng)*8, size: 60, isSlash: true, angle: finalAng });
            }
        }
    }

    // Blood Rain (Stage 3 Only)
    if (s.attack === 'slash_dynamic' && hpPct <= 0.7 && boss.stateTimer % 40 === 0) {
        for(let i=0; i<2; i++) bossProjectiles.push({ x: Math.random()*canvas.width, y: -20, vx: 0, vy: 5.5, size: 20 });
    }

    // Hit Detection
    playerProjectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy;
        let hbW = boss.w * s.hitBoxMult, hbH = boss.h * s.hitBoxMult;
        let hbX = boss.x + (boss.w - hbW)/2, hbY = boss.y + (boss.h - hbH)/2;
        if (p.x > hbX && p.x < hbX + hbW && p.y > hbY && p.y < hbY + hbH) {
            if (boss.flicker <= 0) { 
                boss.hp--; boss.flicker = 8; hitStop = 3; shake = 7; 
                createSparks(p.x, p.y, s.bc); updateUI(); 
                if (boss.hp <= 0) { currentStage++; initStage(); } 
            }
            playerProjectiles.splice(i, 1);
        }
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) playerProjectiles.splice(i, 1);
    });

    bossProjectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy;
        let px = player.x + (player.w - player.hw) / 2, py = player.y + (player.h - player.hh) / 2;
        if (p.x > px && p.x < px + player.hw && p.y > py && p.y < py + player.hh && player.inv <= 0 && player.dashTimer <= 0) {
            player.hp--; player.inv = 60; shake = 12; updateUI(); 
            createSparks(p.x, p.y, "#f00"); bossProjectiles.splice(i, 1);
        }
        if (p.y < -100 || p.y > canvas.height + 100 || p.x < -100 || p.x > canvas.width + 100) bossProjectiles.splice(i, 1);
    });

    // Cleanup
    sparks.forEach((sp, i) => { sp.x += sp.vx; sp.y += sp.vy; sp.life -= 0.03; if (sp.life <= 0) sparks.splice(i, 1); });
    muzzleFlashes.forEach((f, i) => { f.life--; if (f.life <= 0) muzzleFlashes.splice(i, 1); });
    afterImages.forEach((img, i) => { img.opacity -= 0.04; if (img.opacity <= 0) afterImages.splice(i, 1); });
    if (player.inv > 0) player.inv--;
    if (boss.flicker > 0) boss.flicker--;
    if (player.hp <= 0) { isDead = true; document.getElementById('death-screen').style.display = 'flex'; }
}

function draw() {
    ctx.save();
    if (shake > 0 && !isPaused) { ctx.translate(Math.random()*shake - shake/2, Math.random()*shake - shake/2); shake *= 0.9; }

    let s = STAGES[currentStage % STAGES.length];
    if (isImgLoaded(images.background)) ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = s.bgClr; ctx.fillRect(0, 0, canvas.width, canvas.height); }

    s.plats.forEach(p => {
        if (isImgLoaded(images.platform)) {
            for(let tx = 0; tx < p[2]; tx += PLAT_HEIGHT) {
                let drawW = Math.min(PLAT_HEIGHT, p[2]-tx);
                ctx.drawImage(images.platform, 0, 0, images.platform.width * (drawW/PLAT_HEIGHT), images.platform.height, p[0] + tx, p[1], drawW, PLAT_HEIGHT);
            }
        } else { ctx.fillStyle = "#444"; ctx.fillRect(p[0], p[1], p[2], PLAT_HEIGHT); }
    });

    if (isImgLoaded(images.floor)) {
        for(let fx = 0; fx < canvas.width; fx += 50) ctx.drawImage(images.floor, fx, FLOOR_Y, 50, 40);
    } else { ctx.fillStyle = "#111"; ctx.fillRect(0, FLOOR_Y, canvas.width, 40); }

    let renderBossW = boss.w;
    if (isImgLoaded(images.boss)) renderBossW = boss.h * (images.boss.naturalWidth / images.boss.naturalHeight);

    afterImages.forEach(img => {
        ctx.globalAlpha = img.opacity;
        if (img.isPlayer && isImgLoaded(images.player)) {
            ctx.save(); ctx.translate(img.x + img.w/2, img.y + img.h/2); ctx.scale(img.dir, 1); ctx.drawImage(images.player, -img.w/2, -img.h/2, img.w, img.h); ctx.restore();
        } else if (isImgLoaded(images.boss)) ctx.drawImage(images.boss, img.x + (boss.w - renderBossW)/2, img.y, renderBossW, boss.h);
    });
    ctx.globalAlpha = 1.0;

    sparks.forEach(sp => { ctx.globalAlpha = sp.life; ctx.fillStyle = sp.color; ctx.fillRect(sp.x, sp.y, sp.size, sp.size); });
    ctx.globalAlpha = 1.0;

    if (boss.flicker % 2 === 0) {
        if (isImgLoaded(images.boss)) ctx.drawImage(images.boss, boss.x + (boss.w - renderBossW)/2, boss.y, renderBossW, boss.h);
        else { ctx.fillStyle = s.bc; ctx.fillRect(boss.x, boss.y, boss.w, boss.h); }
    }

    // PROJECTILE RENDERER WITH PNG SUPPORT
    bossProjectiles.forEach(p => {
        if (p.isSlash) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            if (isImgLoaded(images.slash)) {
                ctx.drawImage(images.slash, -p.size/2, -p.size/4, p.size, p.size/2);
            } else {
                ctx.fillStyle = s.bc;
                ctx.shadowBlur = 10; ctx.shadowColor = s.bc;
                ctx.fillRect(-p.size/2, -3, p.size, 6);
                ctx.fillStyle = "#fff"; 
                ctx.fillRect(-p.size/2, -1, p.size, 2);
            }
            ctx.restore();
        } else if (isImgLoaded(images.bullet)) {
            ctx.drawImage(images.bullet, p.x-p.size/2, p.y-p.size/2, p.size, p.size);
        } else {
            ctx.fillStyle = s.bc;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2); ctx.fill();
        }
    });

    playerProjectiles.forEach(p => isImgLoaded(images.fireball) ? ctx.drawImage(images.fireball, p.x-p.size/2, p.y-p.size/2, p.size, p.size) : (ctx.fillStyle = "#ff0", ctx.beginPath(), ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2), ctx.fill()));

    if (player.inv % 4 < 2) {
        ctx.save();
        ctx.translate(player.x + player.w/2 + player.recoilX, player.y + player.h/2);
        ctx.scale(player.dir, 1);
        if (isImgLoaded(images.player)) ctx.drawImage(images.player, -player.w/2, -player.h/2, player.w, player.h);
        else { ctx.fillStyle = (player.dashTimer > 0) ? "#fff" : "#5af"; ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h); }
        ctx.restore();
    }

    muzzleFlashes.forEach(f => {
        ctx.fillStyle = "rgba(255, 255, 255, " + (f.life/4) + ")";
        ctx.beginPath(); ctx.arc(f.x, f.y, 15, 0, Math.PI*2); ctx.fill();
    });

    ctx.restore();
    requestAnimationFrame(() => { if(gameStarted) { update(); draw(); } });
}
</script>
</body>
</html>